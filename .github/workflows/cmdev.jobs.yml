name: 'cmdev:jobs-poc'

env:
  GITHUB_ENV: cmdev
  CLUSTER: cs
  AWS_REGION: ap-south-1
  APP_NAME: jobs-poc
  APP_NAMESPACE: cmdev-cs
  VERSION_HELM: v3.5.0
  VERSION_SOPS: v3.7.0
  DOCKER_FILE: deployments/dockerfiles/jobsServer.Dockerfile
  SECRETS_FILE: deployments/environment-vars/secrets.cmdev.yaml
  CONFIG_FILE: deployments/environment-vars/config.cmdev.yaml
  JSONFILE: packages/jobs/src/config.json
  INGRESS_ENABLED: false
  HOST: ''
  SECRET_NAME: ''
  SERVICE_ENABLED: false
  SERVICE_PORT: ''
  LIVENESS_ENABLED: false
  LIVENESS_ENDPOINT: ''
  READINESS_ENABLED: false
  READINESS_ENDPOINT: ''
  CACHE_NAME: node

on: 'workflow_dispatch'

defaults:
  run:
    shell: bash

jobs:
  build_and_push:
    environment: cmdev
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Checkout'
        uses: 'actions/checkout@v2'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - uses: benjlevesque/short-sha@v1.2
        id: short-sha
        with:
          length: 6

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@beta

      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-${{ env.CACHE_NAME }}-cache
          key: ${{ runner.os }}-single-buildx-${{ env.CACHE_NAME }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-single-buildx-${{ env.CACHE_NAME }}

      - name: Build production image
        uses: docker/build-push-action@v2
        with:
          context: .
          builder: ${{ steps.buildx.outputs.name }}
          file: ${{ env.DOCKER_FILE }}
          push: true # This would be set to true in a real world deployment scenario.
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.CLUSTER }}/${{ env.APP_NAME }}:${{ env.GITHUB_ENV }}-${{ steps.short-sha.outputs.sha }}
          cache-from: type=local,src=/tmp/.buildx-${{ env.CACHE_NAME }}-cache
          cache-to: type=local,dest=/tmp/.buildx-${{ env.CACHE_NAME }}-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-${{ env.CACHE_NAME }}-cache
          mv /tmp/.buildx-${{ env.CACHE_NAME }}-cache-new /tmp/.buildx-${{ env.CACHE_NAME }}-cache

  deploy:
    runs-on: 'ubuntu-latest'
    environment: cmdev
    needs: build_and_push
    steps:
      - name: 'Checkout'
        uses: 'actions/checkout@v2'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Setup Helm
        uses: azure/setup-helm@v1.1
        with:
          version: ${{ env.VERSION_HELM }}

      - name: Setup Sops
        uses: mdgreenwald/mozilla-sops-action@v1
        with:
          version: ${{ env.VERSION_SOPS }}

      - name: helm plugin install
        run: |
          plugins=$(helm plugin list)
          if [[ $plugins == *"3.6.0"* ]] && [[ $plugins == *"secrets"* ]]; then
            echo "It's there!"
          else
            helm plugin install https://github.com/jkroepke/helm-secrets --version v3.6.0
          fi

      - uses: benjlevesque/short-sha@v1.2
        id: short-sha
        with:
          length: 6

      - name: 'helm install'
        uses: 'city-mall/helm-jobs@master'
        with:
          secretsCmd: secrets
          helm: helm
          token: '${{ github.token }}'
          secrets: '${{ toJSON(secrets) }}'
          version: '${{ steps.chart.outputs.appVersion }}'
          chart: './deployments/helm'
          namespace: ${{ env.APP_NAMESPACE }}
          release: ${{ env.APP_NAME }}
          values: |
            replicaCount: 1
            number_of_jobs: 3
            jobs:
              enabled: true
            jobnamecron: 'cronname'
            jobnameschedule: 'schedule'
            args: [
              "npm",
              "--prefix",
              "/packages/jobs",
              "start"
            ]
            imagePullSecrets:
              - name: ap-south-1-ecr-registry
            selectorLabels: '${{ env.CLUSTER }}-${{ env.APP_NAME }}'
            labels: '${{ env.CLUSTER }}-${{ env.APP_NAME }}'
            serviceAccount:
              create: false
            podAnnotations: {}
            podSecurityContext: {}
            securityContext: {}
            service:
              enabled: ${{ env.SERVICE_ENABLED }}
              type: ClusterIP
              port: '${{ env.SERVICE_PORT }}'
              targetPort: '${{ env.SERVICE_PORT }}'
              name: '${{ env.SERVICE_PORT }}'
            livenessProbe:
              enabled: ${{ env.LIVENESS_ENABLED }}
              values:
                httpGet:
                  path: '${{ env.LIVENESS_ENDPOINT }}'
                  port: http
            readinessProbe:
              enabled: ${{ env.READINESS_ENABLED }}
              values:
                httpGet:
                  path: '${{ env.READINESS_ENDPOINT }}'
                  port: http
            resources: {}
            autoscaling:
              enabled: false
              minReplicas: 1
              maxReplicas: 100
              targetCPUUtilizationPercentage: 80
            nodeSelector:
              env: staging
            tolerations: []
            affinity: {}
            image:
              repository: '414085459896.dkr.ecr.ap-south-1.amazonaws.com/${{ env.CLUSTER }}/${{ env.APP_NAME }}'
              pullPolicy: Always
              tag: '${{ env.GITHUB_ENV }}-${{ steps.short-sha.outputs.sha }}'
            imagePullSecrets:
              - name: ap-south-1-ecr-registry
            ingress:
              enabled: ${{ env.INGRESS_ENABLED }}
              annotations:
                kubernetes.io/ingress.class: nginx
                cert-manager.io/cluster-issuer: 'letsencrypt-prod'
                ingress.kubernetes.io/force-ssl-redirect: 'true'
              hosts:
                - host: '${{ env.HOST }}'
                  paths:
                    - path: /
                      pathType: Prefix
              tls:
                - secretName: '${{ env.SECRET_NAME }}'
                  hosts:
                    - '${{ env.HOST }}'
          value-files: >-
            [
              "${{ env.SECRETS_FILE }}",
              "${{ env.CONFIG_FILE }}"
            ]
        env:
          KUBECONFIG_FILE: '${{ secrets.KUBECONFIG }}'
